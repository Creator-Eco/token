<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LM Demo</title>
    <link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css>
    <style>
body{
    background-color: black;
    color: #cccccc;
}
#errors{
    display: none;
    background-color: red;
    color: black;
    font-size: 4em;
    text-align: center;
    margin: auto;
}
div.page{
    width: 55em;
    margin: auto;
}
form,table{
    margin: auto;
    width: 100%;
    min-width: 100%;
    padding: 1em;
    margin-top: 1em;
}
table {
    border-collapse: collapse;
}
form{
    border: 1px dotted #333333;
}
input,button{
    display: block;
    margin: 1em;
    background-color: #111111;
    color: #dddddd;
}
tr,th,td{
    font-family:'Lucida Console', monospace;
    border: 1px solid #333333;
    padding: 1em;
}
#dialogue{
    display: none;
    justify-content: center;
    align-items: center;
    position: fixed;
    background-color: #000000dd;
    bottom: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
}
#dialogue div{
    background-color: #000000ff;
    padding: 2em;
}
    </style>
</head>
<body>
    <div class=page>
        <h1>Liquidity Mining Playground</h1>
        <p>
            This is a playground to check if our liquidity mining rewards algorithm is delivering as expected. The way it currently works is as follows:
        </p>
        <ul>
            <li>Once per quarter (defined as exactly 91 days), a reward is sent to contract, marking the end of that quarter.</li>
            <li>At any point, anyone can lock a Bancor position in the contract, stating for how many quarters they wish to lock it (one to twelve)</li>
            <li>At any point, anyone with a locked position can extend the locking period, up to twelve quarters into the future</li>
            <li>At any point, anyone with a locked position can withdraw the rewards he earned during all past quarters, calculated as follows:<ol>
                <li>Let P be the position rewards are being calculated for</li>
                <li>Let Q be the quarter rewards are being calculated for</li>
                <li>Let R be the total amount of BBS tokens rewarded for Q</li>
                <li>Let S be the amount of shares P holds in Q, calculated as follows:<ol>
                    <li>Let A be the amount of BBS tokens deposited into P</li>
                    <li>Let T be the number of quarters from Q till the end of the locking period (inclusive)</li>
                    <li>Let F be the fraction of the quarter during which the position was locked (calculated in a resolution of days and only relevant if Q is the first quarter in which P was locked), calculated as follows:<ol>
                        <li>If Q is not the first quarter in which P is locked, let F = 1</li>
                        <li>If Q is the first quarter in which P is locked:<ol>
                            <li>Let QD be the number of days in Q</li>
                            <li>Let D be day in Q in which P was locked</li>
                            <li>Let F = QD / (QD - D + 1)</li>
                        </ol></li>
                    </ol></li>
                    <li>Let S = A * (91 + ((T - 1) * 26)) * F</li>
                </ol></li>
                <li>Let TS be the total amount of shares for all positions in Q</li>
                <li>Let the reward of P for Q equal: R / TS * S</li>
            </ol>
        </ul>

        <h2>Instructions</h2>
        <p>
            Enter amount of BBS indivisibles (a positive integer) in reward form to simulate sending a quarterly reward into the contract and ending the current quarter.
        </p>
        <p>
            Enter amount of BBS indivisibles (a positive integer), the number of quarters to lock them (an integer between 1 and 12), and the day of the quarter the locking starts in (an integer between 1 and 91) to simulate locking a stake. The new position will appear in the positions table with the following details:
        </p>
        <ul>
            <li>
                The ID of position (randomly generated).
            </li>
            <li>
                The amount of BBS indivisibles locked in the AMM.
            </li>
            <li>
                The number of quarters it is locked for.
            </li>
            <li>
                The amount of shares the position currently has.
            </li>
            <li>
                The amount of unclaimed rewards this position earned.
            </li>
        </ul>
        <p>
            Click any row in the table to extend the locking period, collect rewards, or reclaim the position.
        </p>
        <p>
            Note that a position stops collecting rewards as soon as the commitment is over. Also note that after dividing the rewards, some undivided balance will probably remains as dust.
        </p>

        <form id=rewardForm onsubmit='return false;'>
            Reward amount <input id=rewardAmount>
            <button>Send Reward</button>
            <p>Current quarter: <span id=quartre>0</span></p>
            <p>Rewards:</p>
            <table><thead><tr>
                <th>quarter</th><th>rewards</th>
            </tr></thead><tbody id=rewards></tbody></table>
        </form>

        <form id=lockForm onsubmit='return false;'>
            Amount of BBS in position <input id=lockAmount>
            Locking period in quarters <input id=lockQuarters>
            Day of locking in the quarter <input id=lockDay>
            <button>Lock Position</button>
            <p>Number of positions: <span id=numPositions>0</span></p>
        </form>

        <table><thead><tr>
            <th>position ID</th><th>amount locked</th><th>quarters remaining</th>
            <th>shares</th><th>reward</th><th>unclaimed</th>
        </tr></thead><tbody id=positions></tbody></table>
    </div>
    <div id=errors></div>
    <div id=dialogue><div>
        <button class=extend>extend lock beyond quarter <span class=positionUnlockQuarter></span></button>
        <button class=collect>collect <span class=positionRewards></span> rewards</button>
        <button class=reclaim>reclaim position <span class=positionId></span></button>
        <button class=cancel>cancel</button>
    </div></div>
    <script>
/* jshint esversion: 7*/
const ERRORS_DISPLAY = document.getElementById('errors');
const REWARDS_DISPLAY = document.getElementById('rewards');
const POSITIONS_DISPLAY = document.getElementById('positions');
const NUM_POSITIONS_DISPLAY = document.getElementById('numPositions');
const ACTIONS_DIALOGUE_TEMPLATE = document.getElementById('dialogue');

let currentQuarter = 0;
let rewards = {
    quarters: {},

    get: (index) => {
        if(typeof(index) === 'undefined') index = currentQuarter;
        if(!rewards.quarters.hasOwnProperty(index)) rewards.quarters[index] = {amount: 0, shares: 0};
        return rewards.quarters[index];
    },

    iterate: (last, first, function_) => {
        for(let quarterIdx = last; quarterIdx >= first; quarterIdx--){
            function_(quarterIdx, rewards.get(quarterIdx));
        }
    },

    draw: () => {
        REWARDS_DISPLAY.innerHTML = '';
        rewards.iterate(currentQuarter, 0, (quarterIdx, reward) => {
            let row = document.createElement('tr');
            for(const cellValue of [quarterIdx, reward.amount]){
                let cell = document.createElement('td');
                cell.appendChild(document.createTextNode(cellValue));
                row.appendChild(cell);
            }
            REWARDS_DISPLAY.appendChild(row);
        });
    },

    endQuarter: (amount) => {
        rewards.get().amount += amount;
        currentQuarter++;
        rewards.draw();
    }
};

let locks = {
    positions: {},

    lock: (positionId, lockAmount, lockQuarters, lockDay) => {
        let position = locks.positions[positionId] = locks.positions[positionId] || {
            shares: {},
            lockAmount: lockAmount,
            lockTill: -1,
            claimedReward: 0,
            quartersToGo: () => currentQuarter < position.lockTill ? position.lockTill - currentQuarter : 0,
            currentShares: () => position.shares[currentQuarter] || 0,
            calculateReward: () => {
                let total = 0;
                rewards.iterate(currentQuarter - 1, 0, (quarterIdx, reward) => {
                    total += position.shares[quarterIdx] ? position.shares[quarterIdx] * reward.amount / reward.shares : 0;
                });
                return total;
            },
            reclaim: () => {
                if(currentQuarter < position.lockTill){
                    throw(`position ${positionId} is locked until quarter ${position.lockTill}`);
                }
                delete locks.positions[positionId];
                locks.draw();
            }
        };

        let lockTill = currentQuarter + lockQuarters;
        if(lockTill <= position.lockTill){
            throw(`position ${positionId} is already locked until quarter ${position.lockTill}`);
        }
        position.lockTill = lockTill;

        for(let quarterDelta = 1; quarterDelta <= lockQuarters; quarterDelta++){
            const quarterIdx = position.lockTill - quarterDelta;
            const shares = lockAmount * (91 + ((quarterDelta - 1) * 26)) * (
                quarterDelta === lockQuarters ? (92 - lockDay) / 91 : 1);
            position.shares[quarterIdx] = shares;
            rewards.get(quarterIdx).shares += shares;
        }

        locks.draw();
    },

    draw: () => {
        POSITIONS_DISPLAY.innerHTML = '';
        for(let [positionId, position] of Object.entries(locks.positions)){
            let row = document.createElement('tr');
            for(const cellValue of [
                positionId, position.lockAmount, position.quartersToGo(),
                position.currentShares(), position.calculateReward(), position.claimedReward
            ]){
                let td = document.createElement('td');
                td.appendChild(document.createTextNode(cellValue));
                row.appendChild(td);
            }
            row.addEventListener('click', () => {
                const dialogue = ACTIONS_DIALOGUE_TEMPLATE.cloneNode(true);
                dialogue.style.display = 'flex';
                for(const [name, value] of [
                    ['positionId', positionId],
                    ['positionRewards', position.calculateReward() - position.claimedReward],
                    ['positionUnlockQuarter', position.lockTill]
                ]) dialogue.getElementsByClassName(name)[0].innerHTML = value;
                dialogue.querySelectorAll('button').forEach((button) => {
                    button.addEventListener('click', () => {
                        if([...button.classList].indexOf('extend') !== -1){
                            locks.lock(positionId, position.lockAmount, posIntVal(
                                prompt('specify how many quarters to lock'), 12), 1);
                        }else if([...button.classList].indexOf('collect') !== -1){
                            position.claimedReward = position.calculateReward();
                            locks.draw();
                        }else if([...button.classList].indexOf('reclaim') !== -1){
                            position.reclaim();
                        }
                        dialogue.parentNode.removeChild(dialogue);
                    });
                });
                document.body.appendChild(dialogue);
            });
            POSITIONS_DISPLAY.appendChild(row);
        }
        NUM_POSITIONS_DISPLAY.innerHTML = Object.keys(locks.positions).length;
    }
};

// Get a positive integer value (possibly limited).
function posIntVal(value, limit){
    try{
        value = parseFloat(value, 10);
    }catch(e){
        throw(`not a number - ${value}`);
    }
    if(!Number.isInteger(value)){
        throw(`not an integer - ${value}`);
    }
    if(value < 1){
        throw(`not positive - ${value}`);
    }
    if(limit && value > limit){
        throw(`larger than ${limit} - ${value}`);
    }
    return value;
}

// Get a positive integer value (possibly limited) from the name of an input field.
function inputVal(inputId, limit){
    return posIntVal(document.getElementById(inputId).value, limit);
}

// Bind functionality.
window.addEventListener('error', (error) => {
    ERRORS_DISPLAY.style.display = 'block';
    ERRORS_DISPLAY.innerHTML = error.message.slice(20);
});
window.addEventListener('load', () => {
    rewards.draw();
});
document.getElementById('lockForm').addEventListener('submit', () => {
    locks.lock(
        Math.floor(Math.random() * 2**32),
        inputVal('lockAmount'), inputVal('lockQuarters', 12), inputVal('lockDay', 91));
    return false;
});
document.getElementById('rewardForm').addEventListener('submit', () => {
    rewards.endQuarter(inputVal('rewardAmount'));
    locks.draw();
    return false;
});
    </script>
</body>
</html>
